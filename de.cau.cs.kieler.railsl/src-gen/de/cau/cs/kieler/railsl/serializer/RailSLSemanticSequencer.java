/*
 * generated by Xtext 2.10.0
 */
package de.cau.cs.kieler.railsl.serializer;

import com.google.inject.Inject;
import de.cau.cs.kieler.railsl.railSL.Block;
import de.cau.cs.kieler.railsl.railSL.ConditionalLine;
import de.cau.cs.kieler.railsl.railSL.ConditionalStatement;
import de.cau.cs.kieler.railsl.railSL.ContactWaitStatement;
import de.cau.cs.kieler.railsl.railSL.CrossingStatement;
import de.cau.cs.kieler.railsl.railSL.LightStatement;
import de.cau.cs.kieler.railsl.railSL.ParallelStatement;
import de.cau.cs.kieler.railsl.railSL.PointStatement;
import de.cau.cs.kieler.railsl.railSL.Program;
import de.cau.cs.kieler.railsl.railSL.RailSLPackage;
import de.cau.cs.kieler.railsl.railSL.TimeWaitStatement;
import de.cau.cs.kieler.railsl.railSL.TrackStatement;
import de.cau.cs.kieler.railsl.services.RailSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RailSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RailSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RailSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RailSLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RailSLPackage.CONDITIONAL_LINE:
				sequence_ConditionalLine(context, (ConditionalLine) semanticObject); 
				return; 
			case RailSLPackage.CONDITIONAL_STATEMENT:
				sequence_ConditionalStatement(context, (ConditionalStatement) semanticObject); 
				return; 
			case RailSLPackage.CONTACT_WAIT_STATEMENT:
				sequence_ContactWaitStatement(context, (ContactWaitStatement) semanticObject); 
				return; 
			case RailSLPackage.CROSSING_STATEMENT:
				sequence_CrossingStatement(context, (CrossingStatement) semanticObject); 
				return; 
			case RailSLPackage.LIGHT_STATEMENT:
				sequence_LightStatement(context, (LightStatement) semanticObject); 
				return; 
			case RailSLPackage.PARALLEL_STATEMENT:
				sequence_ParallelStatement(context, (ParallelStatement) semanticObject); 
				return; 
			case RailSLPackage.POINT_STATEMENT:
				sequence_PointStatement(context, (PointStatement) semanticObject); 
				return; 
			case RailSLPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case RailSLPackage.TIME_WAIT_STATEMENT:
				sequence_TimeWaitStatement(context, (TimeWaitStatement) semanticObject); 
				return; 
			case RailSLPackage.TRACK_STATEMENT:
				sequence_TrackStatement(context, (TrackStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement+ end=BLOCK_END)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalLine returns ConditionalLine
	 *
	 * Constraint:
	 *     (contact=ContactIndex segName=SEG_NAME block=Block)
	 */
	protected void sequence_ConditionalLine(ISerializationContext context, ConditionalLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__CONTACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__CONTACT));
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__SEG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__SEG_NAME));
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalLineAccess().getContactContactIndexParserRuleCall_1_0(), semanticObject.getContact());
		feeder.accept(grammarAccess.getConditionalLineAccess().getSegNameSEG_NAMETerminalRuleCall_3_0(), semanticObject.getSegName());
		feeder.accept(grammarAccess.getConditionalLineAccess().getBlockBlockParserRuleCall_5_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ConditionalStatement
	 *     ConditionalStatement returns ConditionalStatement
	 *
	 * Constraint:
	 *     (lines+=ConditionalLine lines+=ConditionalLine+)
	 */
	protected void sequence_ConditionalStatement(ISerializationContext context, ConditionalStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ContactWaitStatement
	 *     WaitStatement returns ContactWaitStatement
	 *     ContactWaitStatement returns ContactWaitStatement
	 *
	 * Constraint:
	 *     ((event='Reach' | event='Pass') contact=ContactIndex segName=SEG_NAME)
	 */
	protected void sequence_ContactWaitStatement(ISerializationContext context, ContactWaitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CrossingStatement
	 *     OpStatement returns CrossingStatement
	 *     CrossingStatement returns CrossingStatement
	 *
	 * Constraint:
	 *     (mode='Open' | mode='Close')
	 */
	protected void sequence_CrossingStatement(ISerializationContext context, CrossingStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LightStatement
	 *     OpStatement returns LightStatement
	 *     LightStatement returns LightStatement
	 *
	 * Constraint:
	 *     (lights+=INT lights+=INT* (lights+=INT | lights+=INT)? (state='on' | state='off'))
	 */
	protected void sequence_LightStatement(ISerializationContext context, LightStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ParallelStatement
	 *     ParallelStatement returns ParallelStatement
	 *
	 * Constraint:
	 *     (blocks+=Block blocks+=Block+)
	 */
	protected void sequence_ParallelStatement(ISerializationContext context, ParallelStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PointStatement
	 *     SetStatement returns PointStatement
	 *     PointStatement returns PointStatement
	 *
	 * Constraint:
	 *     (points+=INT points+=INT* (points+=INT | points+=INT)? (orientation='straight' | orientation='branch'))
	 */
	protected void sequence_PointStatement(ISerializationContext context, PointStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     block=Block
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.PROGRAM__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.PROGRAM__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getBlockBlockParserRuleCall_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TimeWaitStatement
	 *     WaitStatement returns TimeWaitStatement
	 *     TimeWaitStatement returns TimeWaitStatement
	 *
	 * Constraint:
	 *     time=INT+
	 */
	protected void sequence_TimeWaitStatement(ISerializationContext context, TimeWaitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TrackStatement
	 *     SetStatement returns TrackStatement
	 *     TrackStatement returns TrackStatement
	 *
	 * Constraint:
	 *     (segments+=SEG_NAME segments+=SEG_NAME* (segments+=SEG_NAME | segments+=SEG_NAME)? mode=TrackSetting)
	 */
	protected void sequence_TrackStatement(ISerializationContext context, TrackStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
