/*
 * generated by Xtext 2.37.0
 */
package de.cau.cs.kieler.railsl.serializer;

import com.google.inject.Inject;
import de.cau.cs.kieler.railsl.railSL.Block;
import de.cau.cs.kieler.railsl.railSL.ConditionalLine;
import de.cau.cs.kieler.railsl.railSL.ConditionalStatement;
import de.cau.cs.kieler.railsl.railSL.ContactWaitStatement;
import de.cau.cs.kieler.railsl.railSL.CrossingStatement;
import de.cau.cs.kieler.railsl.railSL.LightStatement;
import de.cau.cs.kieler.railsl.railSL.ParallelStatement;
import de.cau.cs.kieler.railsl.railSL.PointStatement;
import de.cau.cs.kieler.railsl.railSL.RailProgram;
import de.cau.cs.kieler.railsl.railSL.RailSLPackage;
import de.cau.cs.kieler.railsl.railSL.TimeWaitStatement;
import de.cau.cs.kieler.railsl.railSL.TrackStatement;
import de.cau.cs.kieler.railsl.services.RailSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RailSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RailSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RailSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RailSLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RailSLPackage.CONDITIONAL_LINE:
				sequence_ConditionalLine(context, (ConditionalLine) semanticObject); 
				return; 
			case RailSLPackage.CONDITIONAL_STATEMENT:
				sequence_ConditionalStatement(context, (ConditionalStatement) semanticObject); 
				return; 
			case RailSLPackage.CONTACT_WAIT_STATEMENT:
				sequence_ContactWaitStatement(context, (ContactWaitStatement) semanticObject); 
				return; 
			case RailSLPackage.CROSSING_STATEMENT:
				sequence_CrossingStatement(context, (CrossingStatement) semanticObject); 
				return; 
			case RailSLPackage.LIGHT_STATEMENT:
				sequence_LightStatement(context, (LightStatement) semanticObject); 
				return; 
			case RailSLPackage.PARALLEL_STATEMENT:
				sequence_ParallelStatement(context, (ParallelStatement) semanticObject); 
				return; 
			case RailSLPackage.POINT_STATEMENT:
				sequence_PointStatement(context, (PointStatement) semanticObject); 
				return; 
			case RailSLPackage.RAIL_PROGRAM:
				sequence_RailProgram(context, (RailProgram) semanticObject); 
				return; 
			case RailSLPackage.TIME_WAIT_STATEMENT:
				sequence_TimeWaitStatement(context, (TimeWaitStatement) semanticObject); 
				return; 
			case RailSLPackage.TRACK_STATEMENT:
				sequence_TrackStatement(context, (TrackStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns Block
	 *     Statement returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement+ end=BlockEnd)
	 * </pre>
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionalLine returns ConditionalLine
	 *
	 * Constraint:
	 *     (contact=ContactPosition segment=RailSegment block=Block)
	 * </pre>
	 */
	protected void sequence_ConditionalLine(ISerializationContext context, ConditionalLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__CONTACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__CONTACT));
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__SEGMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__SEGMENT));
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONDITIONAL_LINE__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalLineAccess().getContactContactPositionEnumRuleCall_1_0(), semanticObject.getContact());
		feeder.accept(grammarAccess.getConditionalLineAccess().getSegmentRailSegmentEnumRuleCall_4_0(), semanticObject.getSegment());
		feeder.accept(grammarAccess.getConditionalLineAccess().getBlockBlockParserRuleCall_10_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ConditionalStatement
	 *     ConditionalStatement returns ConditionalStatement
	 *
	 * Constraint:
	 *     (lines+=ConditionalLine lines+=ConditionalLine+)
	 * </pre>
	 */
	protected void sequence_ConditionalStatement(ISerializationContext context, ConditionalStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ContactWaitStatement
	 *     WaitStatement returns ContactWaitStatement
	 *     ContactWaitStatement returns ContactWaitStatement
	 *
	 * Constraint:
	 *     (event=ContactEvent contact=ContactPosition segment=RailSegment)
	 * </pre>
	 */
	protected void sequence_ContactWaitStatement(ISerializationContext context, ContactWaitStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONTACT_WAIT_STATEMENT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONTACT_WAIT_STATEMENT__EVENT));
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONTACT_WAIT_STATEMENT__CONTACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONTACT_WAIT_STATEMENT__CONTACT));
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CONTACT_WAIT_STATEMENT__SEGMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CONTACT_WAIT_STATEMENT__SEGMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContactWaitStatementAccess().getEventContactEventEnumRuleCall_0_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getContactWaitStatementAccess().getContactContactPositionEnumRuleCall_1_0(), semanticObject.getContact());
		feeder.accept(grammarAccess.getContactWaitStatementAccess().getSegmentRailSegmentEnumRuleCall_4_0(), semanticObject.getSegment());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CrossingStatement
	 *     OpStatement returns CrossingStatement
	 *     CrossingStatement returns CrossingStatement
	 *
	 * Constraint:
	 *     mode=CrossingMode
	 * </pre>
	 */
	protected void sequence_CrossingStatement(ISerializationContext context, CrossingStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.CROSSING_STATEMENT__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.CROSSING_STATEMENT__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCrossingStatementAccess().getModeCrossingModeEnumRuleCall_0_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LightStatement
	 *     OpStatement returns LightStatement
	 *     LightStatement returns LightStatement
	 *
	 * Constraint:
	 *     (lights+=INT lights+=INT* state=LightMode)
	 * </pre>
	 */
	protected void sequence_LightStatement(ISerializationContext context, LightStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ParallelStatement
	 *     ParallelStatement returns ParallelStatement
	 *
	 * Constraint:
	 *     (blocks+=Block blocks+=Block+)
	 * </pre>
	 */
	protected void sequence_ParallelStatement(ISerializationContext context, ParallelStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns PointStatement
	 *     SetStatement returns PointStatement
	 *     PointStatement returns PointStatement
	 *
	 * Constraint:
	 *     (points+=INT points+=INT* orientation=PointOrientation)
	 * </pre>
	 */
	protected void sequence_PointStatement(ISerializationContext context, PointStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RailProgram returns RailProgram
	 *
	 * Constraint:
	 *     block=Block
	 * </pre>
	 */
	protected void sequence_RailProgram(ISerializationContext context, RailProgram semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.RAIL_PROGRAM__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.RAIL_PROGRAM__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRailProgramAccess().getBlockBlockParserRuleCall_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns TimeWaitStatement
	 *     WaitStatement returns TimeWaitStatement
	 *     TimeWaitStatement returns TimeWaitStatement
	 *
	 * Constraint:
	 *     time=INT
	 * </pre>
	 */
	protected void sequence_TimeWaitStatement(ISerializationContext context, TimeWaitStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailSLPackage.Literals.TIME_WAIT_STATEMENT__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailSLPackage.Literals.TIME_WAIT_STATEMENT__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeWaitStatementAccess().getTimeINTTerminalRuleCall_2_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns TrackStatement
	 *     SetStatement returns TrackStatement
	 *     TrackStatement returns TrackStatement
	 *
	 * Constraint:
	 *     (segments+=RailSegment segments+=RailSegment* (speed=TrackSpeedStop | (speed=TrackSpeedDrive reverse?='reverse'?)))
	 * </pre>
	 */
	protected void sequence_TrackStatement(ISerializationContext context, TrackStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
